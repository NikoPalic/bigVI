import numpy as np
from scipy.special import digamma
from sklearn.preprocessing import normalize
from NewtonRaphson import *

def E_phi(beta,gamma,document,k):
    N = len(document)
    phi = np.zeros(shape=(N, k))  # Initialize empty matrix and vector

    for n in range(N):
        for i in range(k):
            phi[n, i] = beta[i, document[n]] * np.exp(
                digamma(gamma[i]) - digamma(np.sum(gamma)))  # There is a typo in the original paper.
    phi = normalize(phi, axis=1, norm='l1') #should maybe normalize by different axis?
    return phi

def E_gamma(alpha,phi):
    gamma = alpha + np.sum(phi, axis=0)
    return gamma

def M_beta(Phi, corpus, k, V):
    beta=np.zeros(shape=(k,V))
    M=len(corpus)
    N = [len(document) for document in corpus]

    for i in range(k):
        for j in range(V):
            b = 0
            for doc_num in range(M):  # documents
                doc = corpus[doc_num]
                Phi_d = Phi[doc_num]
                for n in range(N[doc_num]): #could be optimized
                    if doc[n] == j:
                        b += Phi_d[n, i]
            beta[i, j] = b
    beta = normalize(beta, axis=1, norm='l1')
    return beta

def M_alpha(alpha, Gamma, M, k):
    alpha = newtonRaphson2(k, M, Gamma, alpha)
    return alpha

def full_VI(k, corpus, V, alpha, beta, Gamma):
    M = len(corpus)

    for iteration in range(500):
        print("iteration ", iteration)

        #update Phi (M x N_i x k)
        Phi = []
        for doc_num in range(M):
            document = corpus[doc_num]
            gamma = Gamma[doc_num]

            phi = E_phi(beta, gamma, document, k)
            Phi.append(phi)
        Phi = np.array(Phi);

        #update Gamma (M x k)
        Gamma = []
        for doc_num in range(M):
            phi = Phi[doc_num]

            gamma = E_gamma(alpha, phi)
            Gamma.append(gamma)
        Gamma = np.array(Gamma);

        #update beta (k x V)
        beta = M_beta(Phi, corpus, k, V)

        #update alpha (k)
        alpha = M_alpha(alpha, Gamma, M, k)

        print("Alpha\t", alpha)
        print("Beta\t", beta)

    return alpha, beta
